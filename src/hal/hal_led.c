#include <ez8.h>
#include "hal/led.h"

#define COLUMNS 5
#define ROWS 7
#define DIGITS 4
#define STRING_SIZE 64
#define VIDEO_BUFFER_SIZE 32
#define SLOWNESS 100

#define STRING_LAST_CHAR string[STRING_SIZE]
#define STRING_ID string[STRING_SIZE+1]


static const char character_data[95][5] = {
	{0x00, 0x00, 0x00, 0x00, 0x00},
	{0x00, 0x5F, 0x5F, 0x00, 0x00},
	{0x00, 0x07, 0x00, 0x07, 0x00},
	{0x14, 0x7F, 0x14, 0x7F, 0x14},
	{0x24, 0x2A, 0x7F, 0x2A, 0x12},
	{0x23, 0x13, 0x08, 0x64, 0x62},
	{0x36, 0x49, 0x55, 0x22, 0x50},
	{0x00, 0x05, 0x03, 0x00, 0x00},
	{0x00, 0x1C, 0x22, 0x41, 0x00},
	{0x00, 0x41, 0x22, 0x1C, 0x00},
	{0x14, 0x08, 0x3E, 0x08, 0x14},
	{0x08, 0x08, 0x3E, 0x08, 0x08},
	{0x00, 0x50, 0x30, 0x00, 0x00},
	{0x08, 0x08, 0x08, 0x08, 0x08},
	{0x00, 0x60, 0x60, 0x00, 0x00},
	{0x20, 0x10, 0x08, 0x04, 0x02},
	{0x3E, 0x51, 0x49, 0x45, 0x3E},
	{0x00, 0x42, 0x7F, 0x40, 0x00},
	{0x42, 0x61, 0x51, 0x49, 0x46},
	{0x22, 0x49, 0x49, 0x49, 0x36},
	{0x18, 0x14, 0x12, 0x7F, 0x10},
	{0x2F, 0x49, 0x49, 0x49, 0x31},
	{0x3E, 0x49, 0x49, 0x49, 0x32},
	{0x03, 0x01, 0x71, 0x09, 0x07},
	{0x36, 0x49, 0x49, 0x49, 0x36},
	{0x26, 0x49, 0x49, 0x49, 0x3E},
	{0x00, 0x36, 0x36, 0x00, 0x00},
	{0x00, 0x56, 0x36, 0x00, 0x00},
	{0x08, 0x14, 0x22, 0x41, 0x00},
	{0x14, 0x14, 0x14, 0x14, 0x14},
	{0x00, 0x41, 0x22, 0x14, 0x08},
	{0x02, 0x01, 0x51, 0x09, 0x06},
	{0x32, 0x49, 0x79, 0x41, 0x3E},
	{0x7C, 0x0A, 0x09, 0x0A, 0x7C},
	{0x7F, 0x49, 0x49, 0x49, 0x36},
	{0x3E, 0x41, 0x41, 0x41, 0x22},
	{0x7F, 0x41, 0x41, 0x41, 0x3E},
	{0x7F, 0x49, 0x49, 0x49, 0x41},
	{0x7F, 0x09, 0x09, 0x09, 0x01},
	{0x3E, 0x41, 0x49, 0x49, 0x7A},
	{0x7F, 0x08, 0x08, 0x08, 0x7F},
	{0x00, 0x41, 0x7F, 0x41, 0x00},
	{0x30, 0x40, 0x40, 0x40, 0x3F},
	{0x7F, 0x08, 0x14, 0x22, 0x41},
	{0x7F, 0x40, 0x40, 0x40, 0x40},
	{0x7F, 0x02, 0x0C, 0x02, 0x7F},
	{0x7F, 0x02, 0x04, 0x08, 0x7F},
	{0x3E, 0x41, 0x41, 0x41, 0x3E},
	{0x7F, 0x09, 0x09, 0x09, 0x06},
	{0x3E, 0x41, 0x51, 0x21, 0x5E},
	{0x7F, 0x09, 0x09, 0x09, 0x76},
	{0x26, 0x49, 0x49, 0x49, 0x32},
	{0x01, 0x01, 0x7F, 0x01, 0x01},
	{0x3F, 0x40, 0x40, 0x40, 0x3F},
	{0x1F, 0x20, 0x40, 0x20, 0x1F},
	{0x3F, 0x40, 0x38, 0x40, 0x3F},
	{0x63, 0x14, 0x08, 0x14, 0x63},
	{0x03, 0x04, 0x78, 0x04, 0x03},
	{0x61, 0x51, 0x49, 0x45, 0x43},
	{0x7F, 0x41, 0x41, 0x00, 0x00},
	{0x02, 0x04, 0x08, 0x10, 0x20},
	{0x00, 0x41, 0x41, 0x7F, 0x00},
	{0x04, 0x02, 0x01, 0x02, 0x04},
	{0x40, 0x40, 0x40, 0x40, 0x40},
	{0x00, 0x01, 0x02, 0x04, 0x00},
	{0x20, 0x54, 0x54, 0x54, 0x78},
	{0x7F, 0x48, 0x44, 0x44, 0x38},
	{0x38, 0x44, 0x44, 0x44, 0x20},
	{0x38, 0x44, 0x44, 0x48, 0x7F},
	{0x38, 0x54, 0x54, 0x54, 0x18},
	{0x08, 0x7E, 0x09, 0x01, 0x02},
	{0x0C, 0x52, 0x52, 0x52, 0x3E},
	{0x7F, 0x08, 0x04, 0x04, 0x78},
	{0x00, 0x44, 0x7D, 0x40, 0x00},
	{0x20, 0x40, 0x44, 0x3D, 0x00},
	{0x7F, 0x10, 0x28, 0x44, 0x00},
	{0x00, 0x41, 0x7F, 0x40, 0x00},
	{0x7C, 0x04, 0x18, 0x04, 0x78},
	{0x7C, 0x08, 0x04, 0x04, 0x78},
	{0x38, 0x44, 0x44, 0x44, 0x38},
	{0x7C, 0x14, 0x14, 0x14, 0x08},
	{0x08, 0x14, 0x14, 0x18, 0x7C},
	{0x7C, 0x08, 0x04, 0x04, 0x08},
	{0x48, 0x54, 0x54, 0x54, 0x20},
	{0x04, 0x3F, 0x44, 0x40, 0x20},
	{0x3C, 0x40, 0x40, 0x20, 0x7C},
	{0x1C, 0x20, 0x40, 0x20, 0x1C},
	{0x3C, 0x40, 0x38, 0x40, 0x3C},
	{0x44, 0x28, 0x10, 0x28, 0x44},
	{0x0C, 0x50, 0x50, 0x50, 0x3C},
	{0x44, 0x64, 0x54, 0x4C, 0x44},
	{0x00, 0x08, 0x36, 0x41, 0x00},
	{0x00, 0x00, 0x7F, 0x00, 0x00},
	{0x00, 0x41, 0x36, 0x08, 0x00},
	{0x08, 0x04, 0x08, 0x10, 0x08}
};


static char string[STRING_SIZE+2];
static char mode = 0;
static volatile char should_refresh = 1;




#pragma interrupt
static void timer_irq_handler(void)
{
	should_refresh = 1;
}

static void timer_init(void)
{
	DI(); // Disable interrupts globally
	T0CTL = 0x39; //Disable timer, enable cont. mode, set prescale to 0x80

	T0H = 0x00; //Set high order bits of preset
	T0L = 0x01; //Set low order bits of preset

	// We set the reload value to 0x48 (72) giving us a timer on 0.5 ms
	T0RH = 0x00; //Set high order bits of reload value
	T0RL = 0x48; //Set low order bits of reload value

	//Set IRQ priority to low
	IRQ0ENH = 0x00;
	IRQ0ENL = 0x20;

	T0CTL |= 0x80; //Enable timer
	SET_VECTOR(TIMER0, timer_irq_handler); //Map irq handler
	EI(); // Enable interrupts globally
}

static void reset_video_buffer(char *video_buffer)
{
	int i;
	for (i = 0; i < VIDEO_BUFFER_SIZE; i++) {
		video_buffer[i] = 0;
	}
}

static char should_scroll(void)
{
	static int i = 0;
	i++;
	if (i == SLOWNESS) {
		i = 0;
		return 1;
	} else {
		return 0;
	}
}

static char should_load_next_char(void)
{
	static int i = 0;
	i++;
	if (i == SLOWNESS*6) {
		i = 0;
		return 1;
	} else {
		return 0;
	}
}

static void load_next_char(char *video_buffer, char offset, char *next_ch)
{
	int i;
	int vbi;
	for (i = 0; i < COLUMNS; i++) {
		vbi = (offset + COLUMNS*DIGITS + i) & 0x1F;
		video_buffer[vbi] = character_data[string[*next_ch] - 0x20][i];
	}
	video_buffer[(offset + COLUMNS*DIGITS + COLUMNS) & 0x1F] = 0x00;
	if (string[*next_ch+1] == '\0')
		*next_ch = 0;
	else
		*next_ch += 1;
}

static void do_refresh(char *video_buffer, char offset)
{
	int i, j;
	int vbi;
	for (i = 0; i < COLUMNS; i++) {
		PEOUT = 0x1F & ~(0x10 >> i); // select column
		for (j = 0; j < DIGITS; j++) {
			vbi = (j*COLUMNS+i+offset) & 0x1F;
			PGOUT = 0x7f & video_buffer[vbi]; // write to output reg

			switch(j) {
			case 0: // Write to digit 1
				PEOUT |= 0x80;
				PEOUT &= ~0x80;
				break;
			case 1: // Write to digit 2
				PGOUT |= 0x80;
				PGOUT &= ~0x80;
				break;
			case 2: // Write to digit 3
				PEOUT |= 0x20;
				PEOUT &= ~0x20;
				break;
			case 3: // Write to digit 4
				PEOUT |= 0x40;
				PEOUT &= ~0x40;
				break;
			default:
				break;
			}
		}
	}
}





void hal_led_init(void)
{
	timer_init(); /* initialize timer */

	/* Disable alternate functions */
	PEAF = 0x0;
	PGAF = 0x0;

	/* Configure data direction (output mode) */
	PEDD = 0x0;
	PGDD = 0x0;
}

void hal_led_set_string(char *str)
{
	char i;
	/* copy str to string buffer */
	for (i = 0; i < STRING_SIZE; i++) {
		string[i] = str[i];
	};
	STRING_LAST_CHAR = '\0';
	STRING_ID += 1;
}

void hal_led_set_mode(char m)
{
	mode = m;
}

void hal_led_refresh(void)
{
	static char video_buffer[VIDEO_BUFFER_SIZE];
	static char string_id_old = STRING_ID;
	static char next_ch = 0; /* index of next char to load if scrolling */
	static char offset = 0;

	if (!should_refresh)
		return;
	else
		should_refresh = 1;

	if (string_id_old != STRING_ID) { 
		/* new string has been loaded */
		reset_video_buffer(video_buffer);
		string_id_old = STRING_ID;
		next_ch = 0;
		offset = 0;
		return;
	}

	if (should_scroll()) {
		offset++;
	}

	if (should_load_next_char()) {
		load_next_char(video_buffer, offset, &next_ch);
	}

	do_refresh(video_buffer, offset);
}

